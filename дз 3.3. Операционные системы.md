# ДЗ 3.3. Операционные системы
- 1). Какой системный вызов делает команда cd? 

	- __ Команда CD делает системный вызов chdir()__  
    - __ strace /bin/bash -c 'cd /tmp' 2>&1 | grep tmp__  
   ```
		execve("/bin/bash", ["/bin/bash", "-c", "cd /tmp"], 0x7fffb274a0d0 /* 24 vars */) = 0
		stat("/tmp", {st_mode=S_IFDIR|S_ISVTX|0777, st_size=4096, ...}) = 0
		chdir("/tmp")  
   ```


- 2). Попробуйте использовать команду file на объекты разных типов на файловой системе.
	  Используя strace выясните, 
	  где находится база данных file на основании которой она делает свои догадки.
	  
	  Команда file ищет БД в нескольких местах, в итоге находит здесь - "/usr/share/misc/magic.mgc"
	- __openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3__  

- 3). Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

	- __ Например, приложение c pid 1805 пишет лог в 3-й дескриптор /proc/1805/fd/3__
    - __ Для обнуления удаленного файла лога выполнить команду__
	- __: > /proc/1805/fd/3__
	либо
	- __truncate -s 0 /proc/1805/fd/3__
  
- 4). Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

    - __Не используют ресурсы, т.к. зомби это уже завершившийся процесс, есть только запись в таблице процессов.__

- 5). В iovisor BCC есть утилита opensnoop:
		root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
		/usr/sbin/opensnoop-bpfcc
		На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты?
    - __openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libutil.so.1", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libexpat.so.1", O_RDONLY|O_CLOEXEC) = 3  
		openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libz.so.1", O_RDONLY|O_CLOEXEC) = 3__  

- 6). Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, 
	  где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.   
    - __Используется системный вызов arch_prctl()__

	- Цитата из man
	```
		/proc/version
              This  string  identifies the kernel version that is currently running.  It includes
              the   contents   of   /proc/sys/kernel/ostype,    /proc/sys/kernel/osrelease    and
              /proc/sys/kernel/version.  For example:

        Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994
	```

- 7). Чем отличается последовательность команд через ; и через && в bash?  

 	- __команда после ; выполниться после выполнения предыдущей команды с любым кодом завершения.__
	- __команда после && выполниться после выполнения предыдущей команды только в случае успешного 
		завершения - код выхода 0.__  	
	Есть ли смысл использовать в bash &&, если применить set -e?	
	- __нет смысла использовать &&__
	    
- 8). Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
    - __Удобно использовать в сценариях, тк 1)видно какие команды выполняются, 2)во избежании нанесения вреда скрипт 
	завершиться при наличии ошибок, 3)можно обрабатывать ошибки.__ 
	- __-e немедленный выход, если команда вернет не 0. 
		Это не влияет на последующие команды, если они выполняются после ;, 
		тоесть команды не связаны условием кода выхода предыдущей команды.
		Также опция -е позволяет обработать ошибку перед завершением оболочки.__
	- __-u неустановленные переменные и параметры будут восприниматься как ошибки, 
		за исключением символов @ и *. При этом неинтерактивная оболочка завершит работу__
	- __-x вывод на экран команд с их аргументами перед запуском.__
	- __-o pipefail вернет код выхода 0, если все команды в pipeline вернут код 0. Либо вернет не 0,
	но только в случае, если самая правая команда вернет код выхода не 0.__

- 9). Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. 
В man ps ознакомьтесь (/PROCESS STATE CODES) 
что значат дополнительные к основной заглавной буквы статуса процессов. 
Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

    - __Процессы (I + I<) - 56шт, (S, Ss и Ssl) - 62шт., т.о. процессов с состояние S больше.__  
    - __< -высокий приоритет__
	- __s - глава сессии - SID=PID, process ID of the first member of the session, called the session leader__
	- __l - многопоточный процесс__
