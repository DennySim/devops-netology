# 6.6. Troubleshouting
- 1).
    Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

    Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

    Вы как инженер поддержки решили произвести данную операцию:

    напишите список операций, которые вы будете производить для остановки запроса пользователя
  
    - Поиск длительных запросов
    ```
      db.currentOp(
       {
         "active" : true,
         "secs_running" : { "$gt" : 180 },
         "ns" : /^databasename\./
       }
      )
    ```    
    - Из предыдущего запроса получим opid, и завершим запрос командой ниже
    ```  
      db.killOp(<opid of the query to kill>)
    ```  
    
    предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
    - Для длительных запросов можно создать индекс для запрашиваемых данных,
     с помощью explain оценить улучшение
    
    - Использовать вертикальное и горизонтальное шардирование. 

- 2). Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

    Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
    Причем отношение количества записанных key-value значений к количеству 
    истёкших значений есть величина постоянная и увеличивается пропорционально 
    количеству реплик сервиса.

    При масштабировании сервиса до N реплик вы увидели, что:

    сначала рост отношения записанных значений к истекшим
    Redis блокирует операции записи
    
    Как вы думаете, в чем может быть проблема?
    
    - Приложение вероятно использует LUA скрипты, все операции ждут завершения скрипта. 
    Ключи, используемые в скрипте не истекают до завершения скрипта. Т.о. кол-во
    новых ключей растет, а истекших уменьшается.
    - Также вероятно в конфиге redis установлены следующие параметры:
    min-replicas-to-write <number of replicas>
    min-replicas-max-lag <number of seconds>
    Т.о. мастер-реплика перестанет принимать запросы в случае, если не наберется достаточное 
    кол-во реплик со значениями не превышающими 
    заданный lag(мах кол-во секунд с последнего опроса реплики)

	
- 3). Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.

  Вы подняли базу данных MySQL для использования в гис-системе. 
  При росте количества записей, в таблицах базы, 
  пользователи начали жаловаться на ошибки вида:

  InterfaceError: (InterfaceError) 2013: 
  Lost connection to MySQL server during query u'SELECT..... '  
  Как вы думаете, почему это начало происходить и как локализовать проблему?
      
  - Так как проблема происходит during query, то в связи с 
  увеличением БД,
  выросло время ответа пользователю(выдается больше записей)
  Сервер должен выдать ответ в определенный период, иначе ошибка.
  Настройка позволяющая изменить это время ниже  
  --net_read_timeout=30(default)

  Какие пути решения данной проблемы вы можете предложить?
  - Использовать вертикальное и горизонтальное шардирование
  - Создать индекс для запрашиваемых данных
  - Увеличить таймаут в настройке net_read_timeout
  
      
- 4). Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.

  Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

  После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

  postmaster invoked oom-killer

  Как вы думаете, что происходит?
  - oom-killer завершает приложение, если приложение требует больше памяти.
  Происходит это из-за недостатка ОЗУ или места на swap-разделе
  
  Как бы вы решили данную проблему?   

  - Установить настройку vm.overcommit_memory=2 - ядро не будет резервировать 
  больше памяти, чем указано в настройке overcommit_ratio(default 50%) 
  В overcommit_ratio указывется в процентах кол-во резервируемой памяти для процесса.
  - Увеличить ОЗУ или диск для swap-раздела
   